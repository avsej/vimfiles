if (($term == "rxvt-unicode") || ($term =~ "xterm") || ($term =~ "screen")) && (&termencoding == "")
  set termencoding=utf-8
endif

set cursorline
set undodir=~/.vim/undo
set undofile
set encoding=utf8
set fileencodings=utf-8,cp1251,cp866,koi8-r,iso-8859-15
set spelllang=ru,en
set nocompatible
set fileformat=unix
set viminfo=<1000,s100,'1000,f1,:1000,/1000,n~/.vim/.viminfo
set autowrite
set autoindent
set history=128
set guifont=DejaVu\ Sans\ Mono\ 8
set printencoding=utf8
set printoptions=paper:a4,wrap:y,syntax:n,formfeed:y
set gcr=a:blinkwait0,a:block-cursor
if has("gui_running")
  "set lines=40 columns=130
  set background=light
  colorscheme default
endif
let mapleader = ","
set directory=~/.vim/tmp
set backspace=indent,eol,start
set ruler
set title
set shortmess=ati
set showcmd
set showfulltag
set showmode
set splitbelow
set scrolloff=3
set sidescrolloff=2
set sessionoptions=curdir,buffers
"set mouse=a
set modeline
set modelines=5
set laststatus=2
set statusline=
set statusline+=%f\                           " file name
set statusline+=%=                            " right align
set statusline+=%h%m%r%w                      " flags
set statusline+=%{strlen(&ft)?&ft:'none'}\    " filetype
set statusline+=%{&encoding}\                 " encoding
set statusline+=%{((exists(\"+bomb\")\ &&\ &bomb)?\"b,\":\"\")}  " bom
set statusline+=%{&fileformat}\               " file format
set statusline+=%{GitBranch()}\               " git branch
set statusline+=0x%b\                         " current char
set statusline+=%.(%l,%v%)\ %<%p              " offset

set complete=""
set complete+=.
set complete+=b
set complete+=t
set completeopt=""
"set completeopt=menu
"set completeopt+=preview
"set completeopt+=longest
highlight Pmenu ctermbg=238 gui=bold

set noerrorbells
set hlsearch
set incsearch
set showmatch
"set matchtime=1
set lazyredraw

"set comments=b:#,:%,fb:-,n:>,n:)
set comments=sr:/*,mb:\ *,el:*/,://,b:#,:%,:xcomm,n:>,n:),fb:-
set textwidth=72
"set formatoptions=cqrt
set formatoptions=""
set formatoptions+=c
"set formatoptions+=a
set formatoptions+=w
set formatoptions+=r
set formatoptions+=q
set formatoptions+=n
set cpoptions=$
set joinspaces
set whichwrap+=<,>,[,]
set linebreak
set nowrap
set hidden
set winminheight=1
set shiftround
"set ignorecase
"set smartcase
"set infercase
syntax enable
if has('gui')
  set guioptions-=m
  set guioptions-=t
  set guioptions-=T
  set guioptions-=l
  set guioptions-=l
  set guioptions-=r
end

set wildmode=list:longest
set wildmenu
set wildignore=*.o,*.obj,*~

" enable filetype settings
filetype on
filetype plugin on
filetype indent on

" Quick jumping between splits
nnoremap Y y$
vnoremap < <gv
vnoremap > >gv

"set dictionary=/usr/share/dict/words
set number

set grepprg=grep\ -nHR\ $*

"if has("autocmd") && exists("+omnifunc")
augroup completers autocmd!
  autocmd cursorhold * nohls | redraw
  autocmd bufenter * syntax sync fromstart
  autocmd filetype help nmap <buffer> <return> <c-]>
  autocmd filetype python set omnifunc=pythoncomplete#Complete
  autocmd filetype javascript set omnifunc=javascriptcomplete#CompleteJS
  autocmd filetype html set omnifunc=htmlcomplete#CompleteTags
  autocmd filetype css set omnifunc=csscomplete#CompleteCSS
  autocmd filetype xml set omnifunc=xmlcomplete#CompleteTags
  autocmd filetype php set omnifunc=phpcomplete#CompletePHP
  autocmd filetype sql set omnifunc=sqlcomplete#Complete
  autocmd Filetype *
        \ if &omnifunc == "" |
        \ 	setlocal omnifunc=syntaxcomplete#Complete |
        \ endif

  autocmd bufnewfile,bufread /*/*bash*completion*/*
        \ if expand("<amatch>") !~# "changelog" |
        \ 	let b:is_bash = 1 | set filetype=sh |
        \ endif

  if ($term =~ "screen")
    autocmd vimleave * :set term=screen
  endif
augroup end

nmap <leader>b :shell<cr>
nmap <silent> <f3> :silent nohlsearch<cr>
set pastetoggle=<f12>
noremap <leader>i i<space><esc>r
let c_space_errors = 1
"let c_no_tab_space_error = 1
let omnicpp_namespacesearch = 2
"let omnicpp_selectfirstitem = 2
"let g:autotagctagscmd = "ctags --c++-kinds=+p --fields=+ias --extra=+q"
"nmap ,t :!(cd %:p:h;ctags *.[ch])&

" timestamps for special files
let g:use_timestamp = 1

" git
let g:git_diff_spawn_mode = 1

" vim specific options
let g:vimsyntax_noerror=1

" bash case indet level
let g:sh_indent_case_labels=1

highlight specialkey ctermfg=red guifg=red
set list listchars=tab:\ \ ,trail:·
" settings for explorer.vim
let g:explhidefiles='^\.'
" settings for netrw
let g:netrw_list_hide='^\.,\~$'
" settings for :tohtml
let html_number_lines=1
let html_use_css=1
let html_font="'DejaVu Sans Mono'"
" let use_xhtml=1

let g:tex_indent_items = 1

au bufreadpost *.pdf silent %!pdftotext -nopgbrk "%" - |fmt -csw72
au bufreadpost *.doc silent %!antiword "%"
au bufreadpost *.odt silent %!odt2txt "%"

set langmap=йq,цw,уe,кr,еt,нy,гu,шi,щo,зp,х[,ъ],фa,ыs,вd,аf,пg,рh,оj,лk,дl,ж\\;,э',яz,чx,сc,мv,иb,тn,ьm,б\\,,ю.,ё`,ЙQ,ЦW,УE,КR,ЕT,НY,ГU,ШI,ЩO,ЗP,Х{,Ъ},ФA,ЫS,ВD,АF,ПG,РH,ОJ,ЛK,ДL,Ж:,Э\\",ЯZ,ЧX,СC,МV,ИB,ТN,ЬM,Б<,Ю>,Ё~

" jQuery syntax
au BufRead,BufNewFile *.js set ft=javascript
" Less CSS
au BufNewFile,BufRead *.less set filetype=less
" fbml
au BufNewFile,BufRead *.fbml.erb set filetype=eruby
" JSON
au BufNewFile,BufRead *.json          set filetype=json
" RDF, XML
au BufNewFile,BufRead *.(rdf|xml)     set filetype=xml

au BufNewFile,BufRead *.prawn	set ft=ruby

au BufRead,BufNewFile /opt/nginx/conf/* set ft=nginx

autocmd! BufNewFile * silent! 0r ~/.vim/skel/tmpl.%:e
" For all text files set 'textwidth' to 72 characters.
autocmd FileType text setlocal textwidth=72

" From vimrc_example.vim distributed with Vim 7.
" When editing a file, always jump to the last known cursor position.
" Don't do it when the position is invalid or when inside an event handler
" (happens when dropping a file on gvim).
autocmd BufReadPost *
      \ if line("'\"") > 1 && line("'\"") <= line("$") |
      \   exe "normal! g`\"" |
      \ endif

" Write with sudo :w!!
cmap w!! %!sudo tee > /dev/null %

nmap <silent> <leader>k :cw<cr>

source ~/.vim/etc/abbrev.vim

" Transparent editing of gpg encrypted files.
" By Wouter Hanegraaff
augroup encrypted
 au!

 " First make sure nothing is written to ~/.viminfo while editing
 " an encrypted file.
 autocmd BufReadPre,FileReadPre *.gpg set viminfo=
 " We don't want a swap file, as it writes unencrypted data to disk
 autocmd BufReadPre,FileReadPre *.gpg set noswapfile
 " Switch to binary mode to read the encrypted file
 autocmd BufReadPre,FileReadPre *.gpg set bin
 autocmd BufReadPre,FileReadPre *.gpg let ch_save = &ch|set ch=2
 autocmd BufReadPost,FileReadPost *.gpg '[,']!gpg --decrypt 2> /dev/null
 " Switch to normal mode for editing
 autocmd BufReadPost,FileReadPost *.gpg set nobin
 autocmd BufReadPost,FileReadPost *.gpg let &ch = ch_save|unlet ch_save
 autocmd BufReadPost,FileReadPost *.gpg execute ":doautocmd BufReadPost " . expand("%:r")

 " Convert all text to encrypted text before writing
 autocmd BufWritePre,FileWritePre *.gpg '[,']!gpg --default-recipient-self -ae 2>/dev/null
 " Undo the encryption so we are back in the normal text, directly
 " after the file has been written.
 autocmd BufWritePost,FileWritePost *.gpg u
augroup END

"highlight TooLongLine term=reverse ctermfg=White ctermbg=Red
"match TooLongLine /.\%>101v/

" vim:ft=vim:sw=2:sts=2:et:
